# 데이터베이스

> 기존에 사용하던 파일 시스템은 데이터 종속성, 중복성,무결성 문제가 있었다. DB는 이를 해결했다.

### 특징

1. 독립성
   1. 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 해도 관련된 응용프로그램 수정할 필요 X
   2. 논리적 독립성 : 논리적 구조로 다양한 응용프로그램의 논리적 요구를 만족 시킬 수 있다.
2. 무결성 : 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능, 데이터의 유효성 검사를 통해 구현
3. 보안성 : 인가된 사용자만 DB 접근 가능하게 권한 설정
4. 일관성 : 연관된 정보를 논리적인 구조로 관리함으로써 데이터가 일관적이게 한다.
5. 중복 최소화 : 데이터를 통합해 관리함으로써 파일 시스템의 단점 중 하나인 자료,데이터 중복 해결



### 성능?

> 디스크 I/O를 어떻게 줄이느냐에 달려 있다. (디스크 I/O란 디스크 원판을 돌려 데이터 저장된 위치로 디스크 헤더 이동 시킨후 데이터 읽는 것을 의미) 즉, 디스크의 성능은 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 따라 결정.



## Index

> 색인. 데이터는 책의 내용. 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호
>
> DBMS도 모든 데이터 검색해서 원하는 거 찾으려면 시간 많이 걸림 -> 컬럼의 값과 레코드 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 빠르게 검색하게 함

DBMS의 인덱스는 항상 정렬된 상태이므로 검색은 빠르지만 삭제,수정시 느리다.



### Index 자료구조

> DBMS는 어떻게 인덱스 관리?

#### B+-Tree 인덱스 알고리즘

일반적으로 사용. 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱

#### Hash 인덱스 알고리즘

칼럼의 값으로 해시 값 계산해 인덱싱. 매우 빠른 검색

그러나 값을 변형해 인덱싱하므로, 값의 일부만으로 검색하려면 해시 인덱스 사용 못함

메모리 기반의 DB에서 많이 사용

#### 왜 index를 생성하는데 B-Tree 사용?

hash table은 검색할때 시간이 O(1)인데 왜 안 쓸까?

SELECT 쿼리에 WHERE 조건으로 >< 와 같은 조건을 넣으면, hash table에서는 검색이 어렵다.

따라서 B-Tree를 사용한다.



#### Clustered Index

클러스터드 인덱스 : 비슷한 것들을 묶어서 저장. 비슷한 값들을 동시에 조회하는 경우가 많기 때문

이는 테이블의 프라이머리 키에 대해서만 적용된다. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 `클러스터드 인덱스` 라고 한다.



#### Composite Index

인덱스로 설정하는 필드의 속성이 중요. 따라서 SELECT 질의를 어떻게 할것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼친다.



### Index의 성능과 고려해야할 사항

> SELECT 쿼리의 성능을 월등히 향상시키는 INDEX가 항상 좋은 것일까?

##### > 답은 X

1) Index 생성시 삽입,삭제,업뎃 쿼리 실행 시 별도의 과정이 추가적으로 발생. 그만큼 성능에 손실

2) 컬럼을 이루고 있는 데이터의 형식에 따라 인덱스의 성능이 악영향을 미칠 수도 있음

ex) 값의 range가 적은 인덱스는 인덱스를 읽고 다시 한번 디스크 I/O가 발생해 비효율적이 될 수 있음.