# 카카오 1차 준비

[TOC]

## 계획

### 10.16 토~ 10.17 일 

2차코드 직접 문제점 찾고 개선해보기(O), 지원서 작성(O), 프로젝트 트러블슈팅,갈등상황 정리(O) DB 네트워크 강의 선택(O)



### 10.18 월 ~ 10.24 일

DB,네트워크 + 운체,자구 졸라 열심히 들으면서 정리



### 10.25 월~

최종 정리

## 2차 코드리뷰

### 어떻게 짯는가

1. 초기에 유저들의 점수를 1000점으로 초기화

2. 매 턴 결과 처리
   1. 게임 결과를 받고,  겜 시간이 짧을 수록 점수 변동량을 크게 해서 점수를 증감시켰습니다.
   2. 어뷰저 판별위해 유저별로 10분 이내로 패한 횟수를 기록 10분이내 패횟수가 6회이상이면 어뷰저로 규정, 어뷰저끼리 대전한 경우  실력 높은 사람이 80퍼센트의 확률로 지기 때문에  진 사람의 점수를 올리고, 이긴 사람 점수를 내렸습니다.
   3. 어뷰저와 대전으로 점수를 대량 획득하는 것을 방지하기 위해 10분 이하로 끝난 게임의 경우 점수 증가량을 좀 줄였습니다.
3. 그 다음 매칭
   1. 대기열의 유저들을 점수대 별로 나누어 그룹에 넣었습니다
   2. 어뷰저인 유저들은 어뷰저 대기열에 따로 넣었습니다.
   3. 그 후 점수대 별로 정렬하고 배열에서 2명씩 뽑아서 매칭했습니다.

### 왜 그렇게 짯는가

유저들의 게임 실력에 맞는 점수를 갖게하기 위해 1000점으로 초기화 하고 겜 결과와 시간을 고려해서 점수를 증감시켰고, 유저들 기다리는 시간을 최소화하며 동시에 비슷한 실력의 유저들끼리 대전할 수 있게 대기열의 유저들을 점수가 제일 가까운 2명을 바로바로 매칭 시켰습니다.

### 문제점은 뭐야?

1. 어뷰저들끼리의 대전할 때 실력이 높은 사람이 80퍼 확률로 지기 때문에 진 사람의 점수를 증가시켰어야 했는데, 실수로 진 사람의 점수를 감소시켰습니다.
2. 낮은 점수대 그룹부터 높은 점수대 그룹까지 인원들을 2명씩 매칭시키는 방식인데 낮은 점수대 그룹 인원이 홀수이면 남는 1명이 그 다음 높은 점수대 그룹 1명과 매칭이 되서 실력차가 많이 나는 유저끼리 매칭이 발생할 수 있다. ex) 1000점대 그룹에 1000점 1명, 2500점대 그룹에 2599점 1명, 1000점과 2599점이 매칭된다 
3. 어뷰저를 규정하는 기준을 10분이내 패배 6회 이상으로 했는데, 정말 실력이 낮은 유저의 경우 억울하게 어뷰저로 규정되고 어뷰저끼리만 게임을 하게 되는 경우가 생길 수 있습니다
4. 어뷰저와 대전을 통해 점수를 많이 얻는 경우를 방지하기 위해 10분 이내로 끝난 게임의 경우 원래 점수 증감공식에 따르면 100점이 증가해야 하지만 이를 3으로 나누어 33점만 증가하게 했습니다. 이 때문에 실력이 높은 유저가 점수를 빠르게 올릴 수 없는 단점이 있습니다.
5. 대기열 유저들을 점수대별로 나눠서 그룹을 만들고 정렬해서 매칭시켰음 -> 사실 점수대별로 그룹을 나눌 필요가 없음 정렬하고 가까운 2명씩 붙였기 떄문에

### 개선할 수 있다면 어떤 식으로? (구체적으로)

1. 어뷰저끼리 대전시 진 사람의 점수를 증가시킵니다
2. 점수 차이가 50점 이상 나면 매칭 시키지 않습니다. (효율 성은 좀 떨어지지만 비슷한 유저끼리 매칭해서 만족도는 올라갈 것)
3. 이것은 게임 승패와 시간으로 판별하기 힘들 것이라 생각, 게임 내용을 보고 분석해서 판별해야할 것이라 생각합니다.
4. 실력이 높은 유저의 경우 계속 연승을 할 것입니다. 그래서 연승하는 유저들을 기록해서 연승 시 점수 증가량을 더 주는 방식으로 해결할 수 있을 것입니다. 

5. 점수대별로 그룹을 나누지 않고 대기열 유저들을 정렬한 후 2명씩 매칭시킴

## 자료구조/알고리즘

### 배열과 연결리스트 차이

배열

논리적 저장순서와 물리적 저장순서가 일치, 원소에 인덱스로 접근이 가능 O(1), 그러나 크기가 고정되어 있고, 데이터를 삽입,삭제할 시 다른 데이터들을 shift하는 비용이 든다. O(n)의 시간이 걸림



연결리스트

노드들을 데이터 필드와 다음 노드 주소 필드를 포함하는 노드로 구성, 인덱스로 접근할 수 없음. 논리적 저장 순서와 물리적 저장순서가 불일치 하기 때문, 그러나 크기가 동적이고 데이터 삽입, 삭제할 시 해당 데이터의 앞 뒤 데이터의 주소부분만 수정하면 되서 cost가 적다 O(n)의 시간이 걸림

그리고 다음 원소의 주소를 저장하는 공간이 추가로 필요



### 스택,큐 설명

스택

원소들을 모으는 자료구조, 나중에 들어간 원소가 먼저 나오게 됨. 삽입,삭제시 O(1)의 시간이 걸림

DFS 탐색에 사용

큐

먼저 들어간 원소가 먼저 나오게 됨. 삽입, 삭제시 O(1)의 시간이 걸림 BFS 탐색에 사용,

### 힙

트리의 형태를 가지는데, 최소힙을 예로 들면 각 노드의 값이 자식노드보다 작거나 같은 complete binary tree입니다.

배열로 구현할 수 있음

삽입, 새로운 노드를 힙의 마지막 노드에 삽입, 부모와 비교해서 계속 스왑

삭제, 루트 노드를 삭제하고 마지막 노드를 부모 노드에 놓음, 자식과 비교해서 계속 스왑

삽입 삭제 O(log n)



### 우선순위 큐

들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료구조

배열,연결리스트, 힙으로 구현할 수 있는데 주로 힙으로 많이 구현

배열,연결리스트의 경우 삭제는 O(1)이지만 삽입은 O(n)이 걸림, 힙은 삭제,삽입 O(log n)컷



### 트리

그래프의 일종

값을 가진 노드와 노드를 연결하는 edge로 이루어진 자료구조

부모-자식관계로 이뤄져 있습니다. 계층적인 구조이고 싸이클이 존재 하지 않습니다.

루트에서 한 노드로 가는 경로는 유일함 노드 개수가 N개면 edge는 N-1개입니다.

전위순회 root -> l -> r

중위순회 l -> root -> r

후위 순회 l -> r -> root



### 그래프

노드와  edge로 이뤄진 자료구조

인접행렬,인접리스트 사용해 구현 가능

### Trie

문자열의 검색을 빠르게 도와주는 자료구조

문자열 총 개수 N, 문자열 길이 M

문자열을 배열에 저장하면 검색에 O(N)

루트는 빈 문자, 그 자식으로 문자열 각 글자들을 주렁주렁 달아놓음

검색할 때 각 글자를 쭉 찾으면 됨

단점: 공간 복잡도 

### 해시

데이터를 효율적으로 관리하기 위한 자료 구조 데이터를 key와 value의 쌍으로 저장하고 key값을 배열의 index로 매핑 후 사용해서 검색과 저장을 O(1)에 할 수 있습니다.

이떄 key값을 배열의 index로 변환하는 함수가 해시함수, 키 전체를 참조해 만들고 collision을 최소화하는 방향으로 설계해야함

충돌 해결법

1) open address

충돌발생하면 비어잇는 버킷 탐색함 쭉 찾으며

2) seperate chaining

연결리스트나 트리 사용해서 저장할 것

### B- 트리

이진트리를 확장해서 더 많은 수의 자식을 가질수 있게 한 것

DB의 인덱스 저장 방법으로 많이 쓰임

노드 자료수 N이면 N+1

각 노드의 자료(key)들은 정렬되있음

1,3,5라면 자식은 1보다 작은놈 1< <3 , 3< < 5 , <5, 이렇게 됨 

### DFS,BFS는 어떤 상황에서 써?

DFS - 모든 경우를 탐색해야할 경우(완전 탐색)

BFS - 최단 거리, 최소 비용을 탐색해야할 경우

### 다익스트라 알고리즘이란?

그래프에서 한 노드에서 다른 모든 노드로 가는 최단거리를 구하는 알고리즘

힙을 사용해서 구현할 수 있습니다.

1) 각 노드까지 최단 거리를 기록할 배열을 선언 Dist

2) 최소 힙을 하나 만들고, (0,start) 0과 시작노드를 묶어서 힙에 넣어줍니다.

3) 힙에서 맨 위 노드 하나를 빼서 노드의 인접 노드 중에서

Dist[Next] 기존에 기록한 최단거리 > cost + edge의 cost이면 Dist를 갱신하고 최소힙에 (코스트, 해당 노드)를 넣어줍니다. 

3)을 최소힙이 빌 때까지 계속 반복합니다.

왜 이렇게 될까?

최단 거리를 갱신한다 -> 다시 그 노드에서 시작하는 경로들을 점검해서 계산해야함  



### 소팅 알고리즘

Bubble sort

공간 O(1) 시간 O(n**2)

```
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = i + 1; j < arr.length; j++) {
    	if (arr[i] > arr[j]) {
    		Utils.swapValue(arr, i, j);
    	}
    }
}
```

인접한 2개의 데이터를 비교해가면서 정렬



Selection Sort

공간 O(1) 시간 O(n**2)

```
for i in range(N-1):
    minPos = i
    for j in range(i+1,N):
        if arr[minPos] > arr[j]:
            minPos = j
    swap(i,minPos)
```



Insertion Sort

공간 O(1) 시간 O(n**2)

```
for i in range(1,N):
    temp = arr[i]
    j = i-1
    while j >= 0:
        if temp < arr[j]:
            arr[j+1] = arr[j]
        else:
            break
        j -= 1

    arr[j+1] = temp
```



Merge Sort

공간 O(n) 시간 O(n*logn)

더이상 나누어지지 않을 때까지 반씩 분할하다가 더이상 나누어지지 않은 경우 자기 자신 반환

반환한 값끼리 합칠 때 비교해서 비교 결과를 기반으로 임시 배열에 저장, 이 나눈 것을 병합해서 리턴

```
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    leftList = arr[:mid]
    rightList = arr[mid:]
    leftList = merge_sort(leftList)
    rightList = merge_sort(rightList)
    return merge(leftList, rightList)

def merge(left, right):
    result = []
    while len(left) > 0 or len(right) > 0:
        if len(left) > 0 and len(right):
            if left[0] <= right[0]:
                result.append(left[0])
                left = left[1:]
            else:
                result.append(right[0])
                right = right[1:]
        elif len(left) > 0:
            result.append(left[0])
            left = left[1:]
        elif len(right) > 0:
            result.append(right[0])
            right = right[1:]
        return result
```



heap sort

공간 O(1) or O(n) 시간 O(nlogn)

배열을 heapify 하거나 heap 에 다 넣고 뻄



quick sort

시간 O(n**2) worst 그러나 상수가 작아서 개빨르대

pivot 설정해서 좌에 pivot 보다 작은애 우에 pivot보다 큰애 오게 함

재귀적으로 좌,우 배열에 실행 이떄 pivot한애는 포함안함



worst case? pivot이 항상 배열 내에서 가장 작은,큰 값일 떄 partition이 n , n-1, n-2 ... 요래서 O(n**2)

```
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left ,right = [], []
    for i in range(len(arr)):
        if arr[i] == pivot:
            continue
        elif arr[i] < pivot:
            left.append(arr[i])
        elif arr[i] > pivot:
            right.append(arr[i])
    return quick_sort(left) + [pivot] + quick_sort(right)
```



### 프림,크루스칼

최소 신장 트리 ,

신장 트리 중 edge weight의 합이 최소인 거 신장트리: 그래프의 모든 vertex가 cycle 없이 연결된 형태



최소신장트리를 구하기 위한 2가지 알고리즘

크루스칼

모든 vertex들로만 그래프 구성

edges들을 weight 작은게 앞에오게 정렬

쭉 보면서 그래프에 cycle 안 생기면 edge 추가



어떻게  cycle 여부 판단?

각 노드에 set-id 줌 연결되면 set-id를 하나로 통일 시킴, 이 set-id를 비교하면서 cycle 생기느지 비교



시간 Edge의 weight를 기준으로 정렬 O(ElogE) + cycle 생성 여부 검사 set-id 통일 O(E+VlogV) => O(E log E) 



프림

한개의 vertex로 이뤄진 그래프 구성

내부 vertex로부터 외부 vertex 사이의 edge를 연결하는데 인접한 애들 edge중에 젤 작은거 연결 방문 체크해야겟지

모든 vertex 연결되면 종료



### 이분탐색

탐색 범위를 2 부분으로 분할하면서 탐색

첨부터 끝까지 돌면서 하는거보다 훨 빠름 O(log N)



정렬함

mid = (left+right)/2

찾는 값이 mid보다 큰지 작은지 확인

작으면 right = mid-1 , 크면 left = mid+1

left > right 될떄까지 반복



### 투포인터 알고리즘

부분합 5인거 몇갠지 구할 떄 start end 조작하면서 원하는값ㄱ보다작으면 end 증가 크면 start 증가 이렇게함



## 네트워크,운영체제,DB

폴더 다른 파일에 있음



## 프로젝트

### 프로젝트하면서 어려운 점, 그걸 어떻게 극복했는지

아트메이트 - 웹 SNS 개발

1) 문제점

회원정보 수정 페이지에서 회원정보 수정 시 DB의 데이터는 수정이 되지만 내브바와 회원 정보 페이지의 회원 정보에 수정사항이 반영 되지 않는 문제점이 있었습니다.

2) 해결 방법

다른 팀원이 작성한 코드라 이해하기 어려웠다. 많이 읽어보고 이해 가지 않는 부분들은 물어보면서 코드를 이해했습니다. 회원 정보 수정 시 api를 활용해 DB의 데이터가 수정이 되는것을 확인했습니다. 그러면 데이터를 받아오는 것에 문제점이 있지 않을까 하여 내브바와 회원 정보 페이지에서 어떤 방식으로 회원 정보를 받아서 화면에 표시를 하는지를 확인했습니다. 내브바,회원정보 페이지는 DB에서 회원 정보를 가져오지 않고, vuex라는 통합 저장소에서 회원 정보를 가져옴을 확인했습니다. 그런데 이 vuex의 회원정보는 로그인 시에 유저 정보를 가져와 저장해놓고 그 후 변동사항을 반영하는 로직이 없었습니다. 그래서 회원정보 수정 시 vuex의 mutation을 활용해 vuex의 회원정보도 수정하게 해서 문제를 해결할 수 있었습니다.

3) 얻은 점

내 코드를 다른 사람이 유지 보수할 경우가 있기 때문에 가독성 좋고, 중복이 적은 코드를 작성하는 것이 중요함을 알았습니다. 또, 컴포넌트간 데이터의 흐름을 잘 이해해야 기능적 오류가 발생했을 때 쉽게 해결할 수 있음을 알게 되었습니다.



SSBTI - MBTI 기반 삼성전자 제품 추천 서비스

1) 문제점

고객사(삼성전자 네트워크사업부)의 요청, 갑자기 사람이 몰릴 경우에 대비해서 부하 분산, 확장이 용이한 쿠버네티스를 도입해야 했습니다. 제가 쿠버네티스 초기 환경 설정, CI/CD 환경 구축을 담당했는데 처음 접하는 기술이다보니 너무 어려웠습니다.

2) 해결방법

구글링을 통해 subicura님의 쿠버네티스 기초 가이드를 찾았습니다. 해당 가이드를 정독하고, 예제들을 직접 실습해보면서 기본적인 쿠버네티스 활용법을 익혔습니다.  EC2 환경에서 작은 프로젝트를 직접 쿠버네티스에 올려보며 활용력을 길렀습니다. 그 다음 저희 프로젝트를 쿠버네티스에 올리며 많은 시행착오를 겪고 배포와 Ci/CD환경 구축까지 할 수 있었습니다.

3) 배운 점

새로운 것을 배우는 데에 두려움이 많았는데, 막상 해보니 할 수 있음을 알게 되었습니다. 





### Git Flow 방법론?

처음에 master-develop 브랜치 feature 파서 기능 개발후 develop에 머지, 기능 개발끝낫으면 release 파서 테스트,버그수정 후 develop,master에 merge

master에서 배포

### 팀원과 갈등 상황 있엇나, 어떻게 극복했나

SSBTI - MBTI 기반 삼성전자 제품 추천 서비스 개발 시 어떤 기능들을 쿠버네티스에 올리고 어떤 기능들을 서버리스를 활용할 것인지에 대해 2:3으로 갈렸습니다. 저 포함 2명은 MBTI 검사를 통해 추천 제품을 제공하는 api들을 서버리스로 하자였고, 나머지 3명은 그 반대였습니다. 저희의 근거는 쿠버네티스도 부하 분산,확장 기능이 있지만 사용하는 EC2 환경의 CPU용량이 적어서, 해당 기능을 서버리스에 올려 많은 부하에 대비할 수 있게 하자였고,  반대쪽은 서버리스의 요금이 많이 나오기 때문에 많이 사용하는 기능을 올리면 안된다 였습니다. 그래서 쿠버네티스에 올렸을 때 Jmeter를 통해 얼마나 많은 부하를 견디는지 테스트했습니다. 그 결과 2000명 이상의 동시 요청이 있을 때 서버가 뻗어버리는 경우가 생겼습니다. 그리고 아마존 람다의 경우 100만회 요청까지 무료로 제공하여 요금적인 문제가 발생하지 않을 것임을 알게 되어 MBTI 관련 api들을 아마존 람다에 올리고 다른 기능들을 쿠버네티스에 올리게 되었습니다.



## 마지막 할말,질문



## 면접 실제 질문들

HTTP 전체적 설명

트랜젝션

어레이 링크드리스트

큐 스택

해시맵

힙

퀵소트

졸라 많은 수 배열에서 큰 수 1000개만 뽑는거

2개 배열에서 공통값 뽑기

데드락

데드락 회피

쿠키 세션 정확히 어케 동작

쿠키 클라리언트쪽에서도 만들 수있음?



