# DB 면접 대비

[TOC]

## DB

### 데이터 베이스 사용 이유

파일시스템을 이용해 데이터 관리하면 같은 데이터가 여러파일에 중복 저장, 응용 프로그램이 데이터 파일에 종속적, 데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족한 문제

이런 문제들 해결하는게 DB



### 특징

독립성 :

물리적 독립성 - DB 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 추가해도 응용프로그램을 수정할 필요 x

하위 스키마 변경해도 상위 스키마가 영향 x 매핑만 변경

일관성 : 트랜젝션 통해 일관성 보장

무결성 : 데이터 유효성 검사 통해 무결성 구현

보안성 : 사용자들의 접근 권한 설정 통해 보안

중복 최소화 : 데이터 통합해 관리함으로써 중복 최소화



### 구조

외부 단계 (외부 스키마)

매핑

개념 단계 (개념 스키마)

매핑

내부 단계  (물리 스키마)

## DBMS란

데이터를 데이터베이스에 통합하여 저장하고 관리

## 데이터베이스 설계

요구사항 분석 - 요구사항 명세서

개념적 설계 - 개념적 스키마 (ERD)  개체와 속성 뽑아서 그림



논리적 설계 - 논리적 스키마 (릴레이션 스키마)
물리적 설계 - 물리적 스키마

구현 - SQL문으로 DB생성



## 키

### 키의 특성

유일성: 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가짐

최소성: 꼭 필요한 최소한의 속성들로만 키를 구성



슈퍼키:

유일성 만족 속성,속성들 집합

후보키:

유일성,최소성 만족

기본키:

후보키중 Null값 안 가지고 단순하고 값 자주 변경 안되고 이런 애들 기본키로 설정

대체키:

후보키중 기본키 아닌 애들

외래키:
다른 릴레이션의 기본 키를 참조하는 키, 관계를 표시할 때 씀



## 릴레이션 변환 규칙

1 모든 개체는 릴레이션으로 변환

2 다대다 관계는 릴레이션으로 변환

3 일대다 관계는 외래키

4 일대일 관계는 외래키

5 다중값 속성은 외래키



## 관계 데이터 모델의 무결성 제약 조건

데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙

무결성: 데이터를 결함이 없는 상태, 정확하고 유효하게 유지하는 것



개체 무결성 제약조건: 기본 키를 구성하는 모든 속성은 널 값을 가질 수 없다

참조 무결성 제약조건: 외래키는 참조할 수 없는 값을 가질 수 없다



## 이상현상

중복된 데이터로 인해 데이터 삽입,갱신,삭제 시 발생하는 이상현상

삽입이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 되는 문제

갱신이상 : 중복된 투플 중 일부만 갱신해서 데이터가 불일치하게 되는 문제 

삭제이상 : 데이터 삭제시 필요한 데이터까지 삭제되는 데이터 손실의 문제



## 정규화

이상현상이 발생하지 않도록 함수적 종속성을 활용해 릴레이션을 분해하는 과정

무손실 분해함 -> 정보 손실x, 조인하면 분해 전의 릴레이션으로 복원 가능해야 함



단점: 데이터 조회시 Join이 많이 발생하여 이로 인한 성능 저하가 나타날 수 있음

이 경우 반 정규화 적용



## 반정규화

정규화로 인해 데이터 조회시 Join 많이해서 성능저하되는 경우 적용할 수 있음

테이블 통합(2개 테이블 조인되는 경우 많으면 2개 테이블 합침), 테이블 분할, 중복 테이블 추가, 중복 속성 추가



## 함수적 종속성

릴레이션을 구성하는 속성들의 부분집합 X,Y

하나의 X에 대응하는 Y 값이 항상 동일할 때 X가 Y를 함수적으로 결정 Y는 X에 함수적 종속 X->Y

속성 자체의 특성,의미를 기반으로 판단해야 함



완전 함수 종속: Y가 X에 함수적으로 종속 그러나 X의 부분집합에는 함수적으로 종속 안함

부분 함수 종속: Y가 X에 함수적으로 종속 X의 부분집합에 함수적으로 종속

이행적 함수 종속: X->Y->Z일떄 Z는 X에 이행적 함수 종속



## 정규형

제1정규형

모든 속성 값이 원자값을 가진다

이상현상 발생함 (부분 함수 종속 있어서)

부분 함수 종속이 제거되도록 하면 제2정규형됨



제2 정규형

기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2정규형

이상현상 발생 (이행적 함수 종속 있어서)

이행적 함수 종속 제거하면 제3정규형됨



제 3정규형

기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않음



## Index

RDBMS에서 검색 속도를 높여주는 자료 구조

특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장.

이 인덱스 컬럼을 Where 조건으로 걸면 인덱스 타고 빠르게 검색 가능

장점: 데이터들이 정렬되어 조건 검색 빠르게 가능

단점: 정렬된 상태를 계속 유지해야함, 테이블 내 데이터가 추가,수정되면 INDEX 테이블을 다시 정렬해야함 , 추가적인 저장공간이 필요 , 정렬에 따라 발생하는 부하를 줄이기 위해 INSERT 시 새 데이터 대한 인덱스 추가, DELETE 시 삭제하는 데이터 인덱스를 사용하지 않음 표시, UPDATE: 기존 인덱스를 사용하지 않음 처리하고 갱신된 데이터에 대해 인덱스 추가

사용하면 좋은 경우: WHERE 절에 자주 등장하는 컬럼, 중복되는 데이터가 최소한인 분포도가 좋은 컬럼, ORDER BY 절에서 자주 사용되는 컬럼

구현: B+ tree

## 트랜젝션

데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

상태 변화 -> SQL 쿼리를 통해 DB에 접근 (SELECT, INSERT, UPDATE, DELETE)

작업 단위 -> 사람들이 하는 작업에서 묶음



### 특징 ACID

원자성(Atomicity) - 트랜젝션이 DB에 모두 반영되던가, 아니면 전혀 반영되지 않아야 함

일관성(Consistency) - 트랜젝션의 작업 처리 결과가 항상 일관성 있어야 함, 트랜젝션 진행되는 동안 DB가 변경되면 변경된 DB로 트랜젝션 진행하는 것이 아닌 처음 참조한 DB로 진행, 사용자는 일관성 있는 DB 볼수 있다

독립성(Isolation) - 둘 이상의 트랜젝션이 동시에 실행되고 있을 떄, 하나의 트랜젝션은 다른 트랜젝션에 끼어들 수 없다. 즉, 특정 트랜젝션이 완료될 때까지 다른 트랜젝션이 이 트랜젝션의 결과를 참조할 수 없다

지속성(Durability) - 트랜젝션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다



### Commit, Rollback

Commit : 하나의 트랜젝션이 성공적으로 끝났고, 데이터 베이스가 일관성 있는 상태에 있을 때 이 것을 알리기 위해 사용, 이 연산 사용시 수행한 트랜젝션이 로그에 저장

Rollback : 트랜젝션이 비정상 종료되어 일관성 깨진 경우, 부분적으로 연산된 결과를 취소시킴



### Savepoint

해당 지점 백업 저장포인트 만들어서

rollback to a 이런식으로 돌아갈 수 있음



### 예시

```
START TRANSACTION

UPDATE 잔고
SET 잔액 = 잔액 + 2000
WHERE 이름 = 현우

savepoint a

UPDATE 잔고
SET 잔액 = 잔액 - 2000
WHERE 이름 = 세웅

savepoint b

COMMIT
```

## 트랜젝션 병행 제어

동시에 여러개의 트랜젝션을 수행할 때 실행되는 트랜젝션들이 DB의 일관성 파괴하지 않도록 제어하는 기술



DB 공유 최대화, 시스템 활용도 최대화, 응답 시간 최소화, 일관성 유지





병행 제어 없이 트랜젝션들이 DB에 동시에 접근하게 하면 여러 문제 발생

갱신 분실 : 2개 이상 트랜젝션이 같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상(덮어쓰기)

모순성(불일치성) : 복수의 사용자가 동시에 같은 데이터 갱신할 때 DB내의 데이터가 일치하지 않아 모순된 결과 발생

연쇄 복귀: 병행 수행되던 트랜젝션들 중 어느 하나에 문제가 생겨 Rollback되는 경우 다른 트랜젝션들도 Rollback되는 현상



## 트랜젝션 isolated level

트랜잭션에서 일관성 없는 데이터를 허용하는 수준입니다.

동시에 여러 트랜젝션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것



낮은 트랜잭션 isolated level에서 발생 가능한 문제점

Dirty Read 선행 트랜젝션에서 A 테이블을 SELECT 한 후 후행 트랜젝션에서 A 테이블 UPDATE하는 상황에서 후행 트랜젝션이 UPDATE 후 COMMIT 하지 않았는데, 선행 트랜젝션 SELECT에서 변경된 데이터를 읽을 수 있게 되는 상황

Non-Repeatable Read T1이 A 테이블에서 SELECT, T2가 A 테이블에 접근하여 데이터 변경,또는 삭제후 COMMIT 하면 이후 T1이 다시 A테이블에서 SELECT 하면 T2에 의해 변경 또는 삭제된 데이터를 찾게됨

Phantom Read 트랜젝션 1이 A 테이블에서 데이터를 SELECT 하고 난 후 트랜젝션2 에서 A테이블에서 데이터를 INSERT 또는 DELETE 하는 상황에서 트랜젝션1이 다시 A테이블에서 데이터를 SELECT 할 경우 데이터가 추가되거나 사라지는 현상



Level 0 : Read Uncommitted

트랜잭션이 처리중이거나 아직 Commit 되지 않은 데이터를 다른 트랜젝션이 읽는 것을 허용

일관성 유지 x



Level 1 : Read Committed

Commit 이루어진 트랜젝션만 조회 가능

대부분 DBMS가 Default로 사용하는 isolation LEvel

Non-repeatable read, Phantom read



Level 2 : Repeatable Read

트랜젝션 범위내에서 접근한 데이터 내용이 항상 동일함을 보장

접근중인 데이터에 대해 다른 트랜젝션에서 변경 하건 안하건 현재 트랜젝션에 반영x

다른 트랜잭션이 새로운 데이터를 삽입했을 때 현재 트랜젝션에서 새 데이터 조회 가능

Phantom read



Level 3: Serializable

트랜젝션이 접근 중인 데이터에 대해 다른 트랜젝션의 모든 접근이 불가능

완벽한 일관성



## NoSql

비관계형 데이터 모델로 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 DB를 말합니다.

대량의 비정형 데이터를 저장,조회하는데 특화되어 있습니다. 가용성을 위해 데이터 복제 등의 방법으로 RDBMS가 제공 못하는 성능을 제공

mongodb

일관성 - 분산 노드간의 일관성 보장 위해 2가지 방식 사용, 1) 데이터 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터 저장 ( 느린 응답시간, 데이터 일관성) 2) 메모리나 임시 파일에 기록하고 클라이언트에 응답 후 특정 이벤트,프로세스 사용하여 노드간 데이터 동기화(빠른 응답시간, 쓰기 노드에 장애 발생시 데이터 손실) 

가용성 - 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야함, 몇몇 Nosql은 가용성 보장위해 데이터 복제, 동일한 데이터를 다중 노드에 중복 저장해서 특정 노드 망가져도 정상 응답



종류

key-value 모델

키 하나로 데이터 저장,조회 복잡한 조회 연산 x , 고속 읽기 쓰기 에 최적화 , 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생 시 트랜젝션 처리 불가 ex)Redis



Document 모델

하나의 키에 하나의 구조화된 문서 저장,조회 문서 ID에 대한 인덱스 생성 인덱스 사용해 O(1) 시간 안에 문서 조회 가능 ex) MongoDB



Column Model

하나의 키에 여러 개의 칼럼 이름과 칼럼 값의 쌍으로 이뤄진 데이터 저장,조회