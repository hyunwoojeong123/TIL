# 네이버 인턴 면접준비

[TOC]

## 준비해야 할 것들



JS 코어 - 내 정리본

커링 함수, object.create(null) 등 직접 써보기

React - 정리본

Graphql 

Next.js - 내 프젝 쭉 보고, 정리본도 보고 하기

Typescript 



https://www.edureka.co/blog/interview-questions/typescript-interview-questions/







## 면접 질문들

### 인터프리터 언어 vs 컴파일 언어

인터프리터 언어는 원시 코드(프로그래머가 작성한 소스코드)를 기계어로 변환하는 과정 없이 한줄 한줄 해석하여 바로 명령어를 실행하는 언어 R, Python, Ruby

인터프리터가 직접 한 줄씩 읽고 따로 기계어로 변환하지 않기 때문에 빌드 시간이 없다. Runtime 상황에서는 한 줄 씩 실시간으로 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느리다.

실행 속도는 느리지만 코드 변경 시 빌드 과정 없이 바로 실행이 가능하다는 장점이 있다.



컴파일 언어는 원시코드(프로그래머가 작성한 소스코드)를 모두 기계어로 변환한 후에 기계(JVM 같은 가상 머신)에 넣고 기계어 코드를 실행. 소스 코드를 기계어로 번역하는 빌드 과정에서는 인터프리터 언어에 비해 시간이 소요, 하지만 런타임 상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 빠르게 실행 가능. C, C++, Java

### 자바스크립트 ES 몇버전인지 무슨 기능 추가됐는지

ES 2021

https://chanyeong.com/blog/post/29

String.prototype.replaceAll - 지정한 모든 문자열을 특정한 문자열로 변환

Promise.any() - iterable한 Promise들을 인자로 받아 첫 번째로 해결된 Promise가 생기면 단락되고 값을 반환

WEakRefs - 약한 참조

Logical assignment operators - 논리 할당 연산자 `obj.prop = obj.prop || foo(); `

Numeric seperators - 숫자 구분 기호

```
// before
10000000000 // 100억

// after
10_000_000_000 // 100억
```



### 메소드 체이닝

OOP에서 여러 메소드를 이어서 호출하는 문법

메소드가 객체(this)를 반환하여 여러 메소드를 순차적으로 선언할 수 있도록 함

장점: 코드가 간결해져 하나의 문장처럼 읽히게 할 수 있다. 유지보수에 도움

단점: 하나의 라인에 너무 많은 일이 일어날 수 있어 디버깅 하기 어렵다

https://my-devblog.tistory.com/5

```javascript
class DBConnector {
    constructor(host, port, user, passwd) { 
        this.host = host; 
        this.port = port; 
        this.user = user; 
        this.passwd = passwd; 
    } 
    
    setHost(host) {
        this.host = host; 
        return this; 
    } 
    
    setPort(port) {
        this.port = port; 
        return this; 
    } 
    
    setUser(user) {
        this.user = user; 
        return this; 
    } 
    
    setPasswd(passwd) { 
        this.passwd = passwd; 
        return this; 
    } 
    
    connect() {
        console.log('host: ' + this.host + '\n' + 'port: ' + this.port + '\n' + 		'user: ' + this.user + '\n' + 'passwd: ' + this.passwd); 
    } 
}


```

 메소드 체이닝 적용하기 전

```
const dbc = new DBConnector();
dbc.setHost('127.0.0.1');
dbc.setPort('8080'); 
dbc.setUser('username');
dbc.setPasswd('passwd'); 
dbc.connect();
```

메소드 체이닝 적용 후

```javascript
const dbc = new DBConnector().setHost('127.0.0.1').setPort('8080').setUser('username').setPasswd('passwd').connect();

```



### 웹팩

https://medium.com/@woody_dev/js-webpack-1-%EC%9B%B9%ED%8C%A9%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-f29ebca31da4

오픈소스 자바스크립트 모듈 번들러로써 여러 개로 나눠져 있는 파일들을 하나의 자바스크립트 코드로 압축하고 최적화하는 라이브러리

장점

1. 여러 파일의 JS 코드를 압축, 최적화하여 로딩에 대한 네트워크 비용을 줄일 수 있다
2. 모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽다
3. 최신 자바스크립트 문법을 지원하지 않는 브라우저에서 사용할 수 있는 코드로 쉽게 변환시켜 준다.

수많은 JS 파일이 하나의 파일로 묶인다면 초기 로딩속도가 커질 수 있음. 이를 청크, 캐시, 코드 스플릿 개념들을 도입해서 이 문제를 해결

Entry, Output, Loaders, Plugins, Mode로 구성

#### Entry

웹팩이 빌드할 파일의 시작 위치

entry 지점으로부터 import되어 있는 다른 모듈과 라이브러리에 대한 의존성을 찾는다.

entry의 디폴트로 설정된 값은 ./src/index.js

```
module.exports = {
  entry: ' ./src/index.js'
};
```

#### Output

웹팩에 의해 생성되는 번들을 내보낼 위치와 파일의 이름을 지정

output의 기본값은 ./dist/main.js

```
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  }
};
```

#### Loaders

JS 파일이 아닌 다른 파일들도 유효한 모듈로 변환

loaders의 설정은 싱글 모듈에 대한 rules 프로퍼티를 정의해야 하며, rules 프로퍼티는 test와 use를 필수 프로퍼티로 가지고 있다.

test 프로퍼티는 변환해야 하는 파일 또는 파일들을 식별하는 역할

use 프로퍼티는 변환되어야 하는 파일에 대하여 어떤 로더를 사용해야 하는지 설정

```
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};
```

#### Plugins

번들된 결과물 처리

번들된 자바스크립트를 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용



```
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
```

#### Mode

웹팩을 세팅함에 있어서 development, production, none 중 하나를 파라미터로 사용

production은 최적화되어 빌드되어진다

development는 빠르게 빌드

none은 아무 기능 없이 웹팩으로 빌드



#### 정리

웹팩은 entry로 설정된 시작점에서 의존성을 가진 모든 파일을 압축하여 output지점에 하나의 자바스크립트 파일을 만들어 준다. 이때, 자바스크립트가 아닌 파일은 loaders를 이용하여 자바스크립트에서 이용가능한 모듈로 만들어 주며, plugins를 이용하여 번들된 자바스크립트를 난독화하거나 특정 텍스트를 추출하는 역할을 합니다. mode는 웹팩의 사용 목적에 따라 설정을 지정하는 역할을 합니다.

### 크로스 브라우징

브라우저나 플랫폼마다 보여지는 모습이 다른 경우가 많은데, 이러한 차이를 최소화 하여 브라우저, 환경에 영향을 최소한으로 받고 해당 웹 서비스를 사용할 수 있게 최적화 하는 작업

### 바벨

https://devowen.com/293

크로스 브라우징 이슈를 해결하기 위해 생김

ES6+ 버전의 자바스크립트나 타입스크립트, JSX 등 다른 언어로 분류되는 언어들에 대해서도 모든 브라우저에서 동작할 수 있도록 호환성을 지켜준다.

추상화 수준을 유지한 채로 코드를 변화시키는 트랜스파일러의 역할을 한다.



바벨은 세 단계로 빌드를 진행한다.

1. 파싱(Parsing) : 코드를 읽고 추상 구문 트리(AST)로 변환하는 단계
2. 변환(Transforming) : 추상 구문 트리를 변경
3. 출력(Printing) : 변경된 결과물 출력

바벨이 파싱,출력 담당 변환은 플러그인이 함

바벨 플러그인은 바벨이 어떤 코드를 어떻게 변환할 지에 대한 규칙을 나타낸다.

플러그인을 매번 일일이 설정하기 힘듬 -> 필요한 플러그인들을 목적에 따라 세트로 묶어 씀 = 프리셋



폴리필 = 최신 ECMAScript 환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인, 메소드 등을 추가하는 역할



실무에서는 바벨을 직접 사용하는 경우보다는 웹팩으로 통합해서 사용하는 경우가 더 많다. 이 때 로더 형태로 제공되는 'babel-loader'를 사용한다.



### 리액트가 가상돔 비교를 어떻게 하는지

https://yeoulcoding.tistory.com/147

diffing algorithm

가상돔 비교하는 것

DOM 은 트리 구조라 트리 구조 비교해야함 일반적인 트리 구조 비교는 O(n^3)

React는 O(n)의 시간에 해결 -> 필요한 부분만 비교



1. 같은 계층

비슷한 컴포넌트는 트리 내에 동일한 계층 위치, 같은 계층에 있는 컴포넌트들끼리만 비교

2. key가 있는지 확인

하나의 jsx 태그는 자바스크립트 객체로 구성되어 있다. 이 객체에는 해당 객체가 React의 virtual DOM의 요소임을 확인해주는 symbol값과, 각각의 virtual DOM을 고유하게 구분하는 key값이 들어가게 되며, map들을 통해 생성된 요소들의 경우 고유한 키들이 있다. 리액트는 이 키들의 비교를 통해 리스트의 요소가 추가되거나 삭제되었을 때, 해당 내용을 빠르게 감지하고 반영할 수 있다.

### call by value call by reference

call by value

값에 의한 호출, 인자로 받은 값을 복사하여 처리

복사하여 처리하기 때문에 안전. 원래의 값이 보존

복사를 하기 때문에 메모리 사용량 늘어남



call by reference

복사하지 않고 직접 참조를 하기에 빠르다

직접 참조를 하기에 원래 값이 영향을 받음



### 함수형 프로그래밍 뭐야

명령형 프로그래밍 : 무엇을 할 것인지 나타내기보다 어떻게 할 건지를 설명(객체지향, 절차 지향) -> 소프트웨어 크기 커지면 유지보수 매우 힘들다.

이를 해결하기 위해 함수형 프로그래밍 등장 -> 거의 모든 것을 순수함수로 나누어 문제를 해결하는 기법 가독성 높이고 유지보수 용이하게 해줌 - 대입문이 없는 프로그래밍(클린코드 책에서)

특징

Side effect가 없는 순수 함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.

Side effect - 변수의 값이 변경됨, 자료 구조를 제자리에서 수정함, 객체의 필드 값을 설정, 예외나 오류가 발생하며 실행이 중단, 콘솔 또는 파일 I/O가 발생



### 순수함수 뭐임

Side effect가 없는 함수

함수 자체가 독립 적이며 Side-effect가 없기 때문에 Thread에 안전성

병렬 처리를 동기화 없이 진행



### 1급 객체

다음이 가능한 객체

변수나 데이터 구조안에 담을 수 있다.

파라미터로 전달 할 수 있다.

반환값으로 사용할 수 있다.

할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.



### 참조 투명성

동일한 인자에 대해 항상 동일한 결과 반환

참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다.



### test코드 작성해봄?

ㄴㄴ 해보자



