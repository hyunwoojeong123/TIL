# Bitmasking

> 비트를 활용해서 데이터를 이진수로 표현함, 부분집합을 나타내는 등으로 활용 -> 더 빠르고,메모리 사용적고, 간결한 코드

## 비트 연산

### AND - a & b

대응하는 두 비트가 모두 1일 때 1 아니면 0

```
1010 & 1111 = 1010
```

### OR - a | b

대응하는 두 비트가 하나라도 1이면 1 아니면 0

```
1010 | 1111 = 1111
```

### XOR - a ^ b

대응하는 두 비트가 서로 다르면 1 아니면 0

```
1010 ^ 1111 = 0101
```

### NOT - ~a

비트의 값을 반전하여 반환

```
~1010 = 0101
```

### Shift - a>>b, a<<b

```
00001010 << 2 = 00101000
00001010 >> 2 = 00000010
```



## 집합의 표현

{00000} - 1은 포함, 0는 안 포함 

### p번째 원소 추가

```
cur = cur | (1 << p)
```

### p번째 원소 삭제

```
cur = cur & ~(1<<p)
```

### p번째 원소 토글

0에서 1, 1에서 0

```
cur = cur ^ (1 << p)
```

### p번째 원소 확인

```
cur & (1 << p)
```

