# 브라우저 렌더링 순서

1. 브라우저에서 URL 입력
2. 서버에 html파일 요청
3. html 받아와서 1줄씩 읽어서 DOM요소로 변환 - 이 부분을 scripting이라 함
4. 그 다음 CSS 요소를 CSSOM으로 변환
5. 얘를 브라우저 window에 표기를 하기 위해 준비
6. Rendering tree를 만든 다음 각각의 요소들이 어떤 위치에 어느 정도의 크기로 표기될건지 계산 한다.
7. painting, 그 정보를 바탕으로 그림을 그린다.



크게 나누면,

1. html페이지에서 브라우저가 이해할 수 있도록 브라우저만의 언어로 바꾸는 Construction 파트
2. 이렇게 만들어진 브라우저가 이해할 수 있는 Rendering tree를 이용해서 구조를 작성하고 어디에다 배치할 건지 계산을 한 다음에 실제로 브라우저 window에 그림을 그려주는(rendering)하는 Operation 파트로 나뉜다.



#### CSSOM

DOM과 CSS의 요소를 병합한 것

display: none하면 렌더트리에 포함 안돼서 렌더 안됌

opacity 0하거나 visibility hidden 하면 렌더트리에 포함.



#### Construction

DOM 요소로 변환, CSSOM 만듬, RenderTree 만듬



#### Operation

layout, paint, composition을 통해 최종적으로 사용자에게 내용이 보여진다.



#### layout

DOM,CSSOM 기반으로 레이아웃



#### paint

layout에서 계산한 애들을 바로 그림을 그리는게 아니라 각 부분을 잘게잘게 나누어서 이미지를 준비한다.

즉, 각각의 요소을 비트맵데이터 형태로 변환

그리고 layer를 나눠서 레이어 별로 paint를 준비만 해 놓는다.

왜 이렇게 하냐? 브라우저 성능을 위해서 이렇게 함.

만약 레이어 기능 사용안하고 전체적으로 그림 그리면, 웹페이지에서 한 부분만 바뀌어도 전체 웹페이지의 그림을 업데이트 해야하기 때문이다. 레이어 나누면 변경된 부분의 레이어만 변경하면 된다.

예를 들어서 css의 will-change(속성 값이 변화 될지도 모른다고 알려줌)를 쓰면 이 쓴 애들을 새로운 레이어에다가 추가해 놓아서 바꿀 때 얘가 속한 레이어만 바꾸게 한다. 얘를 많이 쓰면 불필요하게 레이어가 많이 만들어진다.



#### composition

미리 준비한 레이어를 순서대로 차곡차곡 브라우저 위에다가 표기한다.

z-index가 높은 애를 젤 나중에, 쌓아나가는 느낌



#### critical rendering path

html페이지에서 브라우저가 표기할 수 있게 하는 단계



#### 어떻게 하면 이 단계를 빠르게 할 수 있을까?

DOM ,CSS요소가 작을 수록 빨라짐.

그래서 불필요한 태그 남용, div태그 남용 쓸 데없이 wrapping 클래스,요소 만드는 것은 자제하자.

최대한 요소들을 작게 만들어야 함.

operation 타임에는 나중에 사용자가 클릭해 요소를 움직이거나 애니메이션 쓸 때, paint가 자주 일어나지 않도록 만드는 것이 중요

예를 들어 translate을 이용해 움직이면 paint는 안 일어남. 왜냐면 레이어가 준비되어 있기 때문에 레이어 위치만 움기면 된다. 즉, composition만 일어나면 됨.

최악의 경우는 layout을 다시 하는 경우 시간이 개 오래 걸림

layout 변경되면 layout 바뀌고 paint,composition 다시 해야돼서 성능이 나빠짐.

애니메이션 넣을 때 layout 다시해야 하면 얘가 꼭 필요한 애인지 생각해보자.