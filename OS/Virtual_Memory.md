# 가상 메모리

> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행 가능하도록 하는 기법

### 장점

- 물리 메모리 크기에 제약받지 않는다.
- 더 많은 프로그램 동시 실행 가능
- 프로그램들이 빠르게 실행



### 가상 메모리가 하는 일

1. 메모리보다 큰 가상주소 공간을 프로그래머에게 제공

#### 가상 주소 공간

- 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현.
- 현재 직접적으로 필요치 않은 메모리 공간은 물리 메모리에 올리지 않음으로써 물리 메모리 절약



2. 프로세스간의 페이지 공유

- 가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유되게 한다.
- 메모리 공유 가능하게 하고 서로 통신하게 한다.
- 각 프로세스들은 라이브러리, 공유 메모리를 자신의 주소공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
- `fork()`를 통한 프로세스 생성과정에서 페이지들이 공유 되는 것을 가능하게 한다.



### Demand Paging

- 프로그램 실행 전에 전체를 메모리에 안올리고 필요한 것만 올리는 전략. 가상메모리 에서 많이 씀
- 가상 메모리는 보통 페이지로 관리한다. 가상메모리에는 실행과정에서 필요한 페이지들만 적재한다.

- 한번도 안 쓴 페이지는 물리 메모리에 적재되지 않는다.

- 프로세스 내의 개별 페이지들은 `페이저(pager)`로 관리. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옴으로써, 시간,공간 절약한다.

#### 페이지 교체

> 프로세스 동작에 필요한 페이지 요청 과정에서 `page fault` 발생하면, 원하는 페이지를 보조저장장치에서 가져온다. 만약 물리 메모리가 모두 사용중이면 페이지 교체를 해야한다.

#### 방법

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
   1. `페이지 교체 알고리즘` 을 통해 희생될 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정
4. 사용자 프로세스 재시작

#### 페이지 교체 알고리즘

##### 1) FIFO 페이지 교체

먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나간다.

- 장점
  - 이해 쉬움
- 단점
  - 오래된 페이지가 중요한 애일 수도 있다.
  - 많이 쓰는애를 교체해서 `page fault`를 높일 수 있다.
  - `Belady의 모순` 페이지 프레임 갯수 늘려도 page fault가 더 많이 발생할 수 있다.

##### 2) 최적 페이지 교체

젤 낮은 page fault, Belady의 모순 발생 안함.

앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.

- 장점
  - 가장 낮은 Page Fault
- 단점
  - 구현 어려움. 미래를 알 수 없다.

##### 3) LRU 페이지 교체

가장 오랫동안 안쓴 페이지를 선택해 교체

1)보다 좋고 2)보다 꾸졌다.

##### 4) LFU 페이지 교체

참조횟수가 가장 적은 페이지를 교체

- 어떤 프로세스가 특정 페이지를 집중적으로 쓰다가 다른 기능 사용하게 되서 해당 페이지를 사용하지 않아도 계속 메모리에 머물게 되면 괜히 공간만 차지하게 된다.
- OPT를 잘 근사하지 못해 잘 안쓴다.

##### 5) MFU 페이지 교체

잘 안쓴다. 참조횟수 젤 많은 애를 교체



